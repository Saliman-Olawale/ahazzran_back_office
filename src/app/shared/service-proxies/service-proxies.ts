//----------------------
// <auto-generated>
<<<<<<< HEAD
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
=======
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
>>>>>>> origin/jessica
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class UploadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @param file (optional) 
     * @return OK
     */
    downloadfile(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/uploads/downloadfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDownloadfile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MobileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    motdepasseoublie(body: ReinitializePasswordMobileInputDto): Observable<ReinitializePasswordMobileOutputDto> {
        let url_ = this.baseUrl + "/auth/mobile/motdepasseoublie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMotdepasseoublie(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMotdepasseoublie(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReinitializePasswordMobileOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReinitializePasswordMobileOutputDto>;
        }));
    }

    protected processMotdepasseoublie(response: HttpResponseBase): Observable<ReinitializePasswordMobileOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReinitializePasswordMobileOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    inscription(body: InscriptionInputDto): Observable<InscriptionOutputDto> {
        let url_ = this.baseUrl + "/auth/mobile/inscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InscriptionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InscriptionOutputDto>;
        }));
    }

    protected processInscription(response: HttpResponseBase): Observable<InscriptionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InscriptionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    connexion(body: ConnexionInputDto): Observable<ConnexionOutputDto> {
        let url_ = this.baseUrl + "/auth/mobile/connexion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConnexion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConnexion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConnexionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConnexionOutputDto>;
        }));
    }

    protected processConnexion(response: HttpResponseBase): Observable<ConnexionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnexionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkemail(body: CheckEmailInputDto): Observable<CheckEmailOutputDto> {
        let url_ = this.baseUrl + "/auth/mobile/checkemail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckemail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckemail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckEmailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckEmailOutputDto>;
        }));
    }

    protected processCheckemail(response: HttpResponseBase): Observable<CheckEmailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckEmailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getLangueAndRecompenseForUser(apprenantId: number, langueId: number): Observable<LangueAndRecompenseOutputDto> {
        let url_ = this.baseUrl + "/auth/mobile/getLangueAndRecompenseForUser/{apprenantId}/{langueId}?";
        if (apprenantId === undefined || apprenantId === null)
            throw new Error("The parameter 'apprenantId' must be defined and cannot be null.");
        else
            url_ += "apprenantId=" + encodeURIComponent("" + apprenantId) + "&";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined and cannot be null.");
        else
            url_ += "langueId=" + encodeURIComponent("" + langueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLangueAndRecompenseForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLangueAndRecompenseForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LangueAndRecompenseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LangueAndRecompenseOutputDto>;
        }));
    }

    protected processGetLangueAndRecompenseForUser(response: HttpResponseBase): Observable<LangueAndRecompenseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LangueAndRecompenseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getallLangues(): Observable<LangueMobileOutputDto[]> {
        let url_ = this.baseUrl + "/api/langues/mobile/getallLangues";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallLangues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallLangues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LangueMobileOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LangueMobileOutputDto[]>;
        }));
    }

    protected processGetallLangues(response: HttpResponseBase): Observable<LangueMobileOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LangueMobileOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    editerprofil(body: EditerProfilInputDto): Observable<ConnexionOutputDto> {
        let url_ = this.baseUrl + "/auth/editerprofil";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditerprofil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditerprofil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConnexionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConnexionOutputDto>;
        }));
    }

    protected processEditerprofil(response: HttpResponseBase): Observable<ConnexionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnexionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    changermotdepasse(body: ChangerMotDePasseInputDto): Observable<ConnexionOutputDto> {
        let url_ = this.baseUrl + "/auth/changermotdepasse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangermotdepasse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangermotdepasse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConnexionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConnexionOutputDto>;
        }));
    }

    protected processChangermotdepasse(response: HttpResponseBase): Observable<ConnexionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnexionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BackofficeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    connexion(body: ConnexionBackOfficeInputDto): Observable<ConnexionOutputDto> {
        let url_ = this.baseUrl + "/auth/backoffice/connexion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConnexion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConnexion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConnexionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConnexionOutputDto>;
        }));
    }

    protected processConnexion(response: HttpResponseBase): Observable<ConnexionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnexionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    checkemail(body: ConnexionBackOfficeInputDto): Observable<ConnexionOutputDto> {
        let url_ = this.baseUrl + "/auth/backoffice/checkemail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckemail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckemail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConnexionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConnexionOutputDto>;
        }));
    }

    protected processCheckemail(response: HttpResponseBase): Observable<ConnexionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnexionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @param inputVoice (optional) 
     * @param storedVoiceUrl (optional) 
     * @return OK
     */
    compare(inputVoice: FileParameter | undefined, storedVoiceUrl: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/voice/compare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputVoice === null || inputVoice === undefined)
            throw new Error("The parameter 'inputVoice' cannot be null.");
        else
            content_.append("inputVoice", inputVoice.data, inputVoice.fileName ? inputVoice.fileName : "inputVoice");
        if (storedVoiceUrl === null || storedVoiceUrl === undefined)
            throw new Error("The parameter 'storedVoiceUrl' cannot be null.");
        else
            content_.append("storedVoiceUrl", storedVoiceUrl.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCompare(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UtilisateurServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(utilisateurId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/utilisateur/enable/{utilisateurId}";
        if (utilisateurId === undefined || utilisateurId === null)
            throw new Error("The parameter 'utilisateurId' must be defined.");
        url_ = url_.replace("{utilisateurId}", encodeURIComponent("" + utilisateurId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(utilisateurId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/utilisateur/disable/{utilisateurId}";
        if (utilisateurId === undefined || utilisateurId === null)
            throw new Error("The parameter 'utilisateurId' must be defined.");
        url_ = url_.replace("{utilisateurId}", encodeURIComponent("" + utilisateurId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateUtilisateurInputDto): Observable<CreateOrUpdateUtilisateurOutputDto> {
        let url_ = this.baseUrl + "/api/utilisateur/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateUtilisateurOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateUtilisateurOutputDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<CreateOrUpdateUtilisateurOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateUtilisateurOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<UtilisateurOutputDto[]> {
        let url_ = this.baseUrl + "/api/utilisateur/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UtilisateurOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UtilisateurOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<UtilisateurOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UtilisateurOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(rolePermissionId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/permissions/enable/{rolePermissionId}";
        if (rolePermissionId === undefined || rolePermissionId === null)
            throw new Error("The parameter 'rolePermissionId' must be defined.");
        url_ = url_.replace("{rolePermissionId}", encodeURIComponent("" + rolePermissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(rolePermissionId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/permissions/disable/{rolePermissionId}";
        if (rolePermissionId === undefined || rolePermissionId === null)
            throw new Error("The parameter 'rolePermissionId' must be defined.");
        url_ = url_.replace("{rolePermissionId}", encodeURIComponent("" + rolePermissionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateRolePermissionInputDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/permissions/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getallpermissions(): Observable<PermissionOutputDto[]> {
        let url_ = this.baseUrl + "/api/roles/permissions/getallpermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallpermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallpermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionOutputDto[]>;
        }));
    }

    protected processGetallpermissions(response: HttpResponseBase): Observable<PermissionOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RolesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(roleId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/enable/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(roleId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/disable/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateRoleInputDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/roles/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getpermissionbyrole(roleId: number): Observable<RolePermissionOutputDto> {
        let url_ = this.baseUrl + "/api/roles/getpermissionbyrole/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetpermissionbyrole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetpermissionbyrole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RolePermissionOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RolePermissionOutputDto>;
        }));
    }

    protected processGetpermissionbyrole(response: HttpResponseBase): Observable<RolePermissionOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RolePermissionOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<RoleOutputDto[]> {
        let url_ = this.baseUrl + "/api/roles/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<RoleOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NiveauServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    getNiveauByPoints(body: number): Observable<string> {
        let url_ = this.baseUrl + "/api/niveau/getNiveauByPoints";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNiveauByPoints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNiveauByPoints(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetNiveauByPoints(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    enable(niveauId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/niveau/enable/{niveauId}";
        if (niveauId === undefined || niveauId === null)
            throw new Error("The parameter 'niveauId' must be defined.");
        url_ = url_.replace("{niveauId}", encodeURIComponent("" + niveauId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(niveauId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/niveau/disable/{niveauId}";
        if (niveauId === undefined || niveauId === null)
            throw new Error("The parameter 'niveauId' must be defined.");
        url_ = url_.replace("{niveauId}", encodeURIComponent("" + niveauId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateNiveauInputDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/niveau/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<NiveauOutputDto[]> {
        let url_ = this.baseUrl + "/api/niveau/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NiveauOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NiveauOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<NiveauOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NiveauOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(langueId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/langues/enable/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(langueId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/langues/disable/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateLangueInputDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/langues/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<LangueOutputDto[]> {
        let url_ = this.baseUrl + "/api/langues/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LangueOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LangueOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<LangueOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LangueOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DictionnaireServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(dictionnaireId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dictionnaire/enable/{dictionnaireId}";
        if (dictionnaireId === undefined || dictionnaireId === null)
            throw new Error("The parameter 'dictionnaireId' must be defined.");
        url_ = url_.replace("{dictionnaireId}", encodeURIComponent("" + dictionnaireId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(dictionnaireId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dictionnaire/disable/{dictionnaireId}";
        if (dictionnaireId === undefined || dictionnaireId === null)
            throw new Error("The parameter 'dictionnaireId' must be defined.");
        url_ = url_.replace("{dictionnaireId}", encodeURIComponent("" + dictionnaireId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @param file (optional) 
     * @return OK
     */
    createorupdate(input: string | undefined, file: FileParameter | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dictionnaire/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (input === null || input === undefined)
            throw new Error("The parameter 'input' cannot be null.");
        else
            content_.append("input", input.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<DictionnaireOutputDto[]> {
        let url_ = this.baseUrl + "/api/dictionnaire/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DictionnaireOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DictionnaireOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<DictionnaireOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DictionnaireOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CoursServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @param data (optional) 
     * @param file (optional) 
     * @return OK
     */
    getNiveauByPointsOrRecompenses(typeContent: string, data: string | undefined, file: FileParameter[] | undefined): Observable<NiveauInfo> {
        let url_ = this.baseUrl + "/api/cours/getNiveauByPointsOrRecompenses/{typeContent}";
        if (typeContent === undefined || typeContent === null)
            throw new Error("The parameter 'typeContent' must be defined.");
        url_ = url_.replace("{typeContent}", encodeURIComponent("" + typeContent));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data === null || data === undefined)
            throw new Error("The parameter 'data' cannot be null.");
        else
            content_.append("data", data.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            file.forEach(item_ => content_.append("file", item_.data, item_.fileName ? item_.fileName : "file") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNiveauByPointsOrRecompenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNiveauByPointsOrRecompenses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NiveauInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NiveauInfo>;
        }));
    }

    protected processGetNiveauByPointsOrRecompenses(response: HttpResponseBase): Observable<NiveauInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NiveauInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    enable(coursId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/cours/enable/{coursId}";
        if (coursId === undefined || coursId === null)
            throw new Error("The parameter 'coursId' must be defined.");
        url_ = url_.replace("{coursId}", encodeURIComponent("" + coursId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(coursId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/cours/disable/{coursId}";
        if (coursId === undefined || coursId === null)
            throw new Error("The parameter 'coursId' must be defined.");
        url_ = url_.replace("{coursId}", encodeURIComponent("" + coursId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    definetemplatesdecours(body: Body): Observable<boolean> {
        let url_ = this.baseUrl + "/api/cours/definetemplatesdecours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDefinetemplatesdecours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDefinetemplatesdecours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDefinetemplatesdecours(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateCoursInputDto): Observable<CreateOrUpdateCoursOutputDto> {
        let url_ = this.baseUrl + "/api/cours/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateCoursOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateCoursOutputDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<CreateOrUpdateCoursOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateCoursOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getone(chapitreId: number): Observable<ChapitreGroupOutputDto> {
        let url_ = this.baseUrl + "/api/cours/getone/{chapitreId}";
        if (chapitreId === undefined || chapitreId === null)
            throw new Error("The parameter 'chapitreId' must be defined.");
        url_ = url_.replace("{chapitreId}", encodeURIComponent("" + chapitreId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChapitreGroupOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChapitreGroupOutputDto>;
        }));
    }

    protected processGetone(response: HttpResponseBase): Observable<ChapitreGroupOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChapitreGroupOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getcours(langueId: number, id: number, type: string): Observable<CoursDetailDto[]> {
        let url_ = this.baseUrl + "/api/cours/getcours/{langueId}/{id}/{type}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoursDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoursDetailDto[]>;
        }));
    }

    protected processGetcours(response: HttpResponseBase): Observable<CoursDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CoursDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getAlltemplates(): Observable<CoursDetailTemplateDto[]> {
        let url_ = this.baseUrl + "/api/cours/getAlltemplates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlltemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlltemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CoursDetailTemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CoursDetailTemplateDto[]>;
        }));
    }

    protected processGetAlltemplates(response: HttpResponseBase): Observable<CoursDetailTemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CoursDetailTemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/contes/enable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/contes/disable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @param file (optional) 
     * @return OK
     */
    createorupdate(input: string | undefined, file: FileParameter | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/contes/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (input === null || input === undefined)
            throw new Error("The parameter 'input' cannot be null.");
        else
            content_.append("input", input.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getenable(langueId: number): Observable<ConteOutputDto[]> {
        let url_ = this.baseUrl + "/api/contes/getenable/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetenable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetenable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConteOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConteOutputDto[]>;
        }));
    }

    protected processGetenable(response: HttpResponseBase): Observable<ConteOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConteOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(langueId: number): Observable<ConteOutputDto[]> {
        let url_ = this.baseUrl + "/api/contes/getall/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConteOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConteOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<ConteOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConteOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContenulangueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(contenuLangueId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/contenulangue/enable/{contenuLangueId}";
        if (contenuLangueId === undefined || contenuLangueId === null)
            throw new Error("The parameter 'contenuLangueId' must be defined.");
        url_ = url_.replace("{contenuLangueId}", encodeURIComponent("" + contenuLangueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(contenuLangueId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/contenulangue/disable/{contenuLangueId}";
        if (contenuLangueId === undefined || contenuLangueId === null)
            throw new Error("The parameter 'contenuLangueId' must be defined.");
        url_ = url_.replace("{contenuLangueId}", encodeURIComponent("" + contenuLangueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @param file (optional) 
     * @return OK
     */
    createorupdate(input: string | undefined, file: FileParameter | undefined): Observable<CreateOrUpdateContenuLangueOutputDto> {
        let url_ = this.baseUrl + "/api/contenulangue/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (input === null || input === undefined)
            throw new Error("The parameter 'input' cannot be null.");
        else
            content_.append("input", input.toString());
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrUpdateContenuLangueOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrUpdateContenuLangueOutputDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<CreateOrUpdateContenuLangueOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrUpdateContenuLangueOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getone(langueId: number): Observable<LangueGroupDto> {
        let url_ = this.baseUrl + "/api/contenulangue/getone/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LangueGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LangueGroupDto>;
        }));
    }

    protected processGetone(response: HttpResponseBase): Observable<LangueGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LangueGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChapitresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    enable(input: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/chapitres/enable/{input}";
        if (input === undefined || input === null)
            throw new Error("The parameter 'input' must be defined.");
        url_ = url_.replace("{input}", encodeURIComponent("" + input));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEnable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    disable(input: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/chapitres/disable/{input}";
        if (input === undefined || input === null)
            throw new Error("The parameter 'input' must be defined.");
        url_ = url_.replace("{input}", encodeURIComponent("" + input));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDisable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    createorupdate(body: CreateOrUpdateChapitreInputDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/chapitres/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "*/*"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getall(): Observable<ChapitreOutputDto[]> {
        let url_ = this.baseUrl + "/api/chapitres/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChapitreOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChapitreOutputDto[]>;
        }));
    }

    protected processGetall(response: HttpResponseBase): Observable<ChapitreOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChapitreOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    cours(apprenantId: number, langueId: number): Observable<ChapitreCoursDto[]> {
        let url_ = this.baseUrl + "/api/chapitres/cours/{apprenantId}/{langueId}";
        if (apprenantId === undefined || apprenantId === null)
            throw new Error("The parameter 'apprenantId' must be defined.");
        url_ = url_.replace("{apprenantId}", encodeURIComponent("" + apprenantId));
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCours(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCours(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChapitreCoursDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChapitreCoursDto[]>;
        }));
    }

    protected processCours(response: HttpResponseBase): Observable<ChapitreCoursDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChapitreCoursDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    uploads(fileName: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/uploads/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploads(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProgressionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "http://192.168.252.218:3000";
    }

    /**
     * @return OK
     */
    xptotal(): Observable<number> {
        let url_ = this.baseUrl + "/api/progressions/xptotal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXptotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXptotal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processXptotal(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    top30Apprenants(langueId: number): Observable<ApprenantOuputDto[]> {
        let url_ = this.baseUrl + "/api/progressions/top-30-apprenants/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop30Apprenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop30Apprenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprenantOuputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprenantOuputDto[]>;
        }));
    }

    protected processTop30Apprenants(response: HttpResponseBase): Observable<ApprenantOuputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApprenantOuputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    rangApprenant(apprenantId: number, langueId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/progressions/rang-apprenant/{apprenantId}/{langueId}";
        if (apprenantId === undefined || apprenantId === null)
            throw new Error("The parameter 'apprenantId' must be defined.");
        url_ = url_.replace("{apprenantId}", encodeURIComponent("" + apprenantId));
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRangApprenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRangApprenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRangApprenant(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    listeapprenants(langueId: number): Observable<ApprenantOuputDto[]> {
        let url_ = this.baseUrl + "/api/progressions/listeapprenants/{langueId}";
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListeapprenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListeapprenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApprenantOuputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApprenantOuputDto[]>;
        }));
    }

    protected processListeapprenants(response: HttpResponseBase): Observable<ApprenantOuputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApprenantOuputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    getWeeklyProgression(apprenantId: number, langueId: number): Observable<ProfilDto> {
        let url_ = this.baseUrl + "/api/progressions/getWeeklyProgression/{apprenantId}/{langueId}";
        if (apprenantId === undefined || apprenantId === null)
            throw new Error("The parameter 'apprenantId' must be defined.");
        url_ = url_.replace("{apprenantId}", encodeURIComponent("" + apprenantId));
        if (langueId === undefined || langueId === null)
            throw new Error("The parameter 'langueId' must be defined.");
        url_ = url_.replace("{langueId}", encodeURIComponent("" + langueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "*/*"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyProgression(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyProgression(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfilDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfilDto>;
        }));
    }

    protected processGetWeeklyProgression(response: HttpResponseBase): Observable<ProfilDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfilDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ReinitializePasswordMobileInputDto implements IReinitializePasswordMobileInputDto {
    email!: string;
    password!: string;
    confirmPassword!: string;
    otp!: string;

    [key: string]: any;

    constructor(data?: IReinitializePasswordMobileInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.otp = _data["otp"];
        }
    }

    static fromJS(data: any): ReinitializePasswordMobileInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReinitializePasswordMobileInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["otp"] = this.otp;
        return data;
    }
}

export interface IReinitializePasswordMobileInputDto {
    email: string;
    password: string;
    confirmPassword: string;
    otp: string;

    [key: string]: any;
}

export class ReinitializePasswordMobileOutputDto implements IReinitializePasswordMobileOutputDto {
    status!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IReinitializePasswordMobileOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ReinitializePasswordMobileOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReinitializePasswordMobileOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface IReinitializePasswordMobileOutputDto {
    status: string;
    message: string;

    [key: string]: any;
}

export class InscriptionInputDto implements IInscriptionInputDto {
    email!: string;
    password!: string;
    confirmPassword!: string;
    pseudo!: string;
    langueId!: number;
    niveauId!: number;
    otp!: string;

    [key: string]: any;

    constructor(data?: IInscriptionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.pseudo = _data["pseudo"];
            this.langueId = _data["langueId"];
            this.niveauId = _data["niveauId"];
            this.otp = _data["otp"];
        }
    }

    static fromJS(data: any): InscriptionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InscriptionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["pseudo"] = this.pseudo;
        data["langueId"] = this.langueId;
        data["niveauId"] = this.niveauId;
        data["otp"] = this.otp;
        return data;
    }
}

export interface IInscriptionInputDto {
    email: string;
    password: string;
    confirmPassword: string;
    pseudo: string;
    langueId: number;
    niveauId: number;
    otp: string;

    [key: string]: any;
}

export class InscriptionOutputDto implements IInscriptionOutputDto {
    status!: string;
    message!: string;
<<<<<<< HEAD
    id!: number;
=======
    token!: string;
>>>>>>> origin/jessica

    [key: string]: any;

    constructor(data?: IInscriptionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
<<<<<<< HEAD
            this.id = _data["id"];
=======
            this.token = _data["token"];
>>>>>>> origin/jessica
        }
    }

    static fromJS(data: any): InscriptionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new InscriptionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
<<<<<<< HEAD
        data["id"] = this.id;
=======
        data["token"] = this.token;
>>>>>>> origin/jessica
        return data;
    }
}

export interface IInscriptionOutputDto {
    status: string;
    message: string;
<<<<<<< HEAD
    id: number;
=======
    token: string;
>>>>>>> origin/jessica

    [key: string]: any;
}

export class ConnexionInputDto implements IConnexionInputDto {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: IConnexionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ConnexionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConnexionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IConnexionInputDto {
    email: string;
    password: string;

    [key: string]: any;
}

export class ConnexionOutputDto implements IConnexionOutputDto {
    status!: string;
    message!: string;
    token!: string;
    langueId!: number;
    apprenantId!: number;

    [key: string]: any;

    constructor(data?: IConnexionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
            this.token = _data["token"];
            this.langueId = _data["langueId"];
            this.apprenantId = _data["apprenantId"];
        }
    }

    static fromJS(data: any): ConnexionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConnexionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        data["token"] = this.token;
        data["langueId"] = this.langueId;
        data["apprenantId"] = this.apprenantId;
        return data;
    }
}

export interface IConnexionOutputDto {
    status: string;
    message: string;
    token: string;
    langueId: number;
    apprenantId: number;

    [key: string]: any;
}

export class CheckEmailInputDto implements ICheckEmailInputDto {
    email!: string;
    inscription!: boolean;
    resetPincode!: boolean;

    [key: string]: any;

    constructor(data?: ICheckEmailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.inscription = _data["inscription"];
            this.resetPincode = _data["resetPincode"];
        }
    }

    static fromJS(data: any): CheckEmailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["inscription"] = this.inscription;
        data["resetPincode"] = this.resetPincode;
        return data;
    }
}

export interface ICheckEmailInputDto {
    email: string;
    inscription: boolean;
    resetPincode: boolean;

    [key: string]: any;
}

export class CheckEmailOutputDto implements ICheckEmailOutputDto {
    status!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: ICheckEmailOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CheckEmailOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckEmailOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface ICheckEmailOutputDto {
    status: string;
    message: string;

    [key: string]: any;
}

export class EditerProfilInputDto implements IEditerProfilInputDto {
    id!: number;
    nom!: string;
    prenoms!: string;
    email!: string;
    telephone!: string;

    [key: string]: any;

    constructor(data?: IEditerProfilInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nom = _data["nom"];
            this.prenoms = _data["prenoms"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
        }
    }

    static fromJS(data: any): EditerProfilInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditerProfilInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nom"] = this.nom;
        data["prenoms"] = this.prenoms;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        return data;
    }
}

export interface IEditerProfilInputDto {
    id: number;
    nom: string;
    prenoms: string;
    email: string;
    telephone: string;

    [key: string]: any;
}

export class ChangerMotDePasseInputDto implements IChangerMotDePasseInputDto {
    id!: number;
    motDePasse!: string;

    [key: string]: any;

    constructor(data?: IChangerMotDePasseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.motDePasse = _data["motDePasse"];
        }
    }

    static fromJS(data: any): ChangerMotDePasseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangerMotDePasseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["motDePasse"] = this.motDePasse;
        return data;
    }
}

export interface IChangerMotDePasseInputDto {
    id: number;
    motDePasse: string;

    [key: string]: any;
}

export class ConnexionBackOfficeInputDto implements IConnexionBackOfficeInputDto {
    email!: string;
    otp!: string;

    [key: string]: any;

    constructor(data?: IConnexionBackOfficeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.otp = _data["otp"];
        }
    }

    static fromJS(data: any): ConnexionBackOfficeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConnexionBackOfficeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["otp"] = this.otp;
        return data;
    }
}

export interface IConnexionBackOfficeInputDto {
    email: string;
    otp: string;

    [key: string]: any;
}

export class CreateOrUpdateUtilisateurInputDto implements ICreateOrUpdateUtilisateurInputDto {
    id!: number;
    email!: string;
    roleId!: number;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateUtilisateurInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.email = _data["email"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUtilisateurInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUtilisateurInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["email"] = this.email;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface ICreateOrUpdateUtilisateurInputDto {
    id: number;
    email: string;
    roleId: number;

    [key: string]: any;
}

export class CreateOrUpdateUtilisateurOutputDto implements ICreateOrUpdateUtilisateurOutputDto {
    status!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateUtilisateurOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUtilisateurOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUtilisateurOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface ICreateOrUpdateUtilisateurOutputDto {
    status: string;
    message: string;

    [key: string]: any;
}

export class CreateOrUpdateRolePermissionInputDto implements ICreateOrUpdateRolePermissionInputDto {
    id!: number;
    roleId!: number;
    permissionId!: number;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateRolePermissionInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.permissionId = _data["permissionId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateRolePermissionInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRolePermissionInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["permissionId"] = this.permissionId;
        return data;
    }
}

export interface ICreateOrUpdateRolePermissionInputDto {
    id: number;
    roleId: number;
    permissionId: number;

    [key: string]: any;
}

export class CreateOrUpdateRoleInputDto implements ICreateOrUpdateRoleInputDto {
    id!: number;
    designation!: string;
    codeRole!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateRoleInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.designation = _data["designation"];
            this.codeRole = _data["codeRole"];
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["designation"] = this.designation;
        data["codeRole"] = this.codeRole;
        return data;
    }
}

export interface ICreateOrUpdateRoleInputDto {
    id: number;
    designation: string;
    codeRole: string;

    [key: string]: any;
}

export class CreateOrUpdateNiveauInputDto implements ICreateOrUpdateNiveauInputDto {
    niveauId!: number;
    nom!: string;
    ordre!: number;
    pointMin!: number;
    pointMax!: number;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateNiveauInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.niveauId = _data["niveauId"];
            this.nom = _data["nom"];
            this.ordre = _data["ordre"];
            this.pointMin = _data["pointMin"];
            this.pointMax = _data["pointMax"];
        }
    }

    static fromJS(data: any): CreateOrUpdateNiveauInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateNiveauInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["niveauId"] = this.niveauId;
        data["nom"] = this.nom;
        data["ordre"] = this.ordre;
        data["pointMin"] = this.pointMin;
        data["pointMax"] = this.pointMax;
        return data;
    }
}

export interface ICreateOrUpdateNiveauInputDto {
    niveauId: number;
    nom: string;
    ordre: number;
    pointMin: number;
    pointMax: number;

    [key: string]: any;
}

export class CreateOrUpdateLangueInputDto implements ICreateOrUpdateLangueInputDto {
    id!: number;
    nom!: string;
    code!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateLangueInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nom = _data["nom"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateOrUpdateLangueInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLangueInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nom"] = this.nom;
        data["code"] = this.code;
        return data;
    }
}

export interface ICreateOrUpdateLangueInputDto {
    id: number;
    nom: string;
    code: string;

    [key: string]: any;
}

export class NiveauInfo implements INiveauInfo {
    niveauId!: number;
    estTermine!: boolean;
    isaReprendre!: boolean;
    points!: number;
    nom!: string;
    correctAnswers!: number;
    incorrectAnswers!: number;

    [key: string]: any;

    constructor(data?: INiveauInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.niveauId = _data["niveauId"];
            this.estTermine = _data["estTermine"];
            this.isaReprendre = _data["isaReprendre"];
            this.points = _data["points"];
            this.nom = _data["nom"];
            this.correctAnswers = _data["correctAnswers"];
            this.incorrectAnswers = _data["incorrectAnswers"];
        }
    }

    static fromJS(data: any): NiveauInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NiveauInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["niveauId"] = this.niveauId;
        data["estTermine"] = this.estTermine;
        data["isaReprendre"] = this.isaReprendre;
        data["points"] = this.points;
        data["nom"] = this.nom;
        data["correctAnswers"] = this.correctAnswers;
        data["incorrectAnswers"] = this.incorrectAnswers;
        return data;
    }
}

export interface INiveauInfo {
    niveauId: number;
    estTermine: boolean;
    isaReprendre: boolean;
    points: number;
    nom: string;
    correctAnswers: number;
    incorrectAnswers: number;

    [key: string]: any;
}

export class DefinirCoursInputOuputDto implements IDefinirCoursInputOuputDto {
    id_template!: number;
    id_contenuLangue!: number;
    recompense!: number;
    id_TypeOfContent!: number;

    [key: string]: any;

    constructor(data?: IDefinirCoursInputOuputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id_template = _data["id_template"];
            this.id_contenuLangue = _data["id_contenuLangue"];
            this.recompense = _data["recompense"];
            this.id_TypeOfContent = _data["id_TypeOfContent"];
        }
    }

    static fromJS(data: any): DefinirCoursInputOuputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefinirCoursInputOuputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id_template"] = this.id_template;
        data["id_contenuLangue"] = this.id_contenuLangue;
        data["recompense"] = this.recompense;
        data["id_TypeOfContent"] = this.id_TypeOfContent;
        return data;
    }
}

export interface IDefinirCoursInputOuputDto {
    id_template: number;
    id_contenuLangue: number;
    recompense: number;
    id_TypeOfContent: number;

    [key: string]: any;
}

export class CreateOrUpdateCoursInputDto implements ICreateOrUpdateCoursInputDto {
    id!: number;
    codeCours!: string;
    nomCours!: string;
    chapitreId!: number;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateCoursInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.codeCours = _data["codeCours"];
            this.nomCours = _data["nomCours"];
            this.chapitreId = _data["chapitreId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateCoursInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCoursInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["codeCours"] = this.codeCours;
        data["nomCours"] = this.nomCours;
        data["chapitreId"] = this.chapitreId;
        return data;
    }
}

export interface ICreateOrUpdateCoursInputDto {
    id: number;
    codeCours: string;
    nomCours: string;
    chapitreId: number;

    [key: string]: any;
}

export class CreateOrUpdateCoursOutputDto implements ICreateOrUpdateCoursOutputDto {
    status!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateCoursOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateOrUpdateCoursOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCoursOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface ICreateOrUpdateCoursOutputDto {
    status: string;
    message: string;

    [key: string]: any;
}

export class CreateOrUpdateContenuLangueOutputDto implements ICreateOrUpdateContenuLangueOutputDto {
    status!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateContenuLangueOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateOrUpdateContenuLangueOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateContenuLangueOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface ICreateOrUpdateContenuLangueOutputDto {
    status: string;
    message: string;

    [key: string]: any;
}

export class CreateOrUpdateChapitreInputDto implements ICreateOrUpdateChapitreInputDto {
    chapitreId!: number;
    nomChapitre!: string;
    codeChapitre!: string;

    [key: string]: any;

    constructor(data?: ICreateOrUpdateChapitreInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.chapitreId = _data["chapitreId"];
            this.nomChapitre = _data["nomChapitre"];
            this.codeChapitre = _data["codeChapitre"];
        }
    }

    static fromJS(data: any): CreateOrUpdateChapitreInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateChapitreInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["chapitreId"] = this.chapitreId;
        data["nomChapitre"] = this.nomChapitre;
        data["codeChapitre"] = this.codeChapitre;
        return data;
    }
}

export interface ICreateOrUpdateChapitreInputDto {
    chapitreId: number;
    nomChapitre: string;
    codeChapitre: string;

    [key: string]: any;
}

export class LangueAndRecompenseOutputDto implements ILangueAndRecompenseOutputDto {
    langue!: string;
    recompense!: number;

    [key: string]: any;

    constructor(data?: ILangueAndRecompenseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.langue = _data["langue"];
            this.recompense = _data["recompense"];
        }
    }

    static fromJS(data: any): LangueAndRecompenseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LangueAndRecompenseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["langue"] = this.langue;
        data["recompense"] = this.recompense;
        return data;
    }
}

export interface ILangueAndRecompenseOutputDto {
    langue: string;
    recompense: number;

    [key: string]: any;
}

export class UtilisateurOutputDto implements IUtilisateurOutputDto {
    utilisateurId!: number;
    email!: string;
    roleName!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IUtilisateurOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.utilisateurId = _data["utilisateurId"];
            this.email = _data["email"];
            this.roleName = _data["roleName"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): UtilisateurOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UtilisateurOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["utilisateurId"] = this.utilisateurId;
        data["email"] = this.email;
        data["roleName"] = this.roleName;
        data["active"] = this.active;
        return data;
    }
}

export interface IUtilisateurOutputDto {
    utilisateurId: number;
    email: string;
    roleName: string;
    active: boolean;

    [key: string]: any;
}

export class PermissionOutputDto implements IPermissionOutputDto {
    permissionId!: number;
    intitule!: string;
    codePermission!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IPermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.permissionId = _data["permissionId"];
            this.intitule = _data["intitule"];
            this.codePermission = _data["codePermission"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): PermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["permissionId"] = this.permissionId;
        data["intitule"] = this.intitule;
        data["codePermission"] = this.codePermission;
        data["active"] = this.active;
        return data;
    }
}

export interface IPermissionOutputDto {
    permissionId: number;
    intitule: string;
    codePermission: string;
    active: boolean;

    [key: string]: any;
}

export class RoleOutputDto implements IRoleOutputDto {
    id!: number;
    designation!: string;
    codeRole!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IRoleOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.designation = _data["designation"];
            this.codeRole = _data["codeRole"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): RoleOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["designation"] = this.designation;
        data["codeRole"] = this.codeRole;
        data["active"] = this.active;
        return data;
    }
}

export interface IRoleOutputDto {
    id: number;
    designation: string;
    codeRole: string;
    active: boolean;

    [key: string]: any;
}

export class RolePermissionOutputDto implements IRolePermissionOutputDto {
    role!: RoleOutputDto;
    permissions!: PermissionOutputDto[];

    [key: string]: any;

    constructor(data?: IRolePermissionOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"] ? RoleOutputDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRolePermissionOutputDto {
    role: RoleOutputDto;
    permissions: PermissionOutputDto[];

    [key: string]: any;
}

export class ApprenantOuputDto implements IApprenantOuputDto {
    pseudo!: string;
    rang!: number;
    xp!: number;

    [key: string]: any;

    constructor(data?: IApprenantOuputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pseudo = _data["pseudo"];
            this.rang = _data["rang"];
            this.xp = _data["xp"];
        }
    }

    static fromJS(data: any): ApprenantOuputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprenantOuputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pseudo"] = this.pseudo;
        data["rang"] = this.rang;
        data["xp"] = this.xp;
        return data;
    }
}

export interface IApprenantOuputDto {
    pseudo: string;
    rang: number;
    xp: number;

    [key: string]: any;
}

export class CoursStatutDto implements ICoursStatutDto {
    estTermine!: boolean;
    finalDate!: DateTime;
    point!: number;

    [key: string]: any;

    constructor(data?: ICoursStatutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.estTermine = _data["estTermine"];
            this.finalDate = _data["finalDate"] ? DateTime.fromISO(_data["finalDate"].toString()) : <any>undefined;
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): CoursStatutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursStatutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["estTermine"] = this.estTermine;
        data["finalDate"] = this.finalDate ? this.finalDate.toString() : <any>undefined;
        data["point"] = this.point;
        return data;
    }
}

export interface ICoursStatutDto {
    estTermine: boolean;
    finalDate: DateTime;
    point: number;

    [key: string]: any;
}

export class ProfilDto implements IProfilDto {
    nom!: string;
    pseudo!: string;
    prenoms!: string;
    email!: string;
    langue!: string;
    nbreDePoints!: number;
    niveau!: string;
    telephone!: string;
    xp!: { [key: string]: number; };
    nbreDeJoursActivite!: number;
    progressionsHebdosParLangue!: ProgressionHebdoDto[];

    [key: string]: any;

    constructor(data?: IProfilDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nom = _data["nom"];
            this.pseudo = _data["pseudo"];
            this.prenoms = _data["prenoms"];
            this.email = _data["email"];
            this.langue = _data["langue"];
            this.nbreDePoints = _data["nbreDePoints"];
            this.niveau = _data["niveau"];
            this.telephone = _data["telephone"];
            if (_data["xp"]) {
                this.xp = {} as any;
                for (let key in _data["xp"]) {
                    if (_data["xp"].hasOwnProperty(key))
                        (<any>this.xp)![key] = _data["xp"][key];
                }
            }
            this.nbreDeJoursActivite = _data["nbreDeJoursActivite"];
            if (Array.isArray(_data["progressionsHebdosParLangue"])) {
                this.progressionsHebdosParLangue = [] as any;
                for (let item of _data["progressionsHebdosParLangue"])
                    this.progressionsHebdosParLangue!.push(ProgressionHebdoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProfilDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nom"] = this.nom;
        data["pseudo"] = this.pseudo;
        data["prenoms"] = this.prenoms;
        data["email"] = this.email;
        data["langue"] = this.langue;
        data["nbreDePoints"] = this.nbreDePoints;
        data["niveau"] = this.niveau;
        data["telephone"] = this.telephone;
        if (this.xp) {
            data["xp"] = {};
            for (let key in this.xp) {
                if (this.xp.hasOwnProperty(key))
                    (<any>data["xp"])[key] = (<any>this.xp)[key];
            }
        }
        data["nbreDeJoursActivite"] = this.nbreDeJoursActivite;
        if (Array.isArray(this.progressionsHebdosParLangue)) {
            data["progressionsHebdosParLangue"] = [];
            for (let item of this.progressionsHebdosParLangue)
                data["progressionsHebdosParLangue"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProfilDto {
    nom: string;
    pseudo: string;
    prenoms: string;
    email: string;
    langue: string;
    nbreDePoints: number;
    niveau: string;
    telephone: string;
    xp: { [key: string]: number; };
    nbreDeJoursActivite: number;
    progressionsHebdosParLangue: ProgressionHebdoDto[];

    [key: string]: any;
}

export class ProgressionHebdoDto implements IProgressionHebdoDto {
    chapitreId!: number;
    chapitreNom!: string;
    estTermine!: boolean;
    coursStatuts!: CoursStatutDto[];

    [key: string]: any;

    constructor(data?: IProgressionHebdoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.chapitreId = _data["chapitreId"];
            this.chapitreNom = _data["chapitreNom"];
            this.estTermine = _data["estTermine"];
            if (Array.isArray(_data["coursStatuts"])) {
                this.coursStatuts = [] as any;
                for (let item of _data["coursStatuts"])
                    this.coursStatuts!.push(CoursStatutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgressionHebdoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressionHebdoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["chapitreId"] = this.chapitreId;
        data["chapitreNom"] = this.chapitreNom;
        data["estTermine"] = this.estTermine;
        if (Array.isArray(this.coursStatuts)) {
            data["coursStatuts"] = [];
            for (let item of this.coursStatuts)
                data["coursStatuts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgressionHebdoDto {
    chapitreId: number;
    chapitreNom: string;
    estTermine: boolean;
    coursStatuts: CoursStatutDto[];

    [key: string]: any;
}

export class NiveauOutputDto implements INiveauOutputDto {
    niveauId!: number;
    nom!: string;
    ordre!: number;
    pointMin!: number;
    pointMax!: number;
    active!: boolean;

    [key: string]: any;

    constructor(data?: INiveauOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.niveauId = _data["niveauId"];
            this.nom = _data["nom"];
            this.ordre = _data["ordre"];
            this.pointMin = _data["pointMin"];
            this.pointMax = _data["pointMax"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): NiveauOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new NiveauOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["niveauId"] = this.niveauId;
        data["nom"] = this.nom;
        data["ordre"] = this.ordre;
        data["pointMin"] = this.pointMin;
        data["pointMax"] = this.pointMax;
        data["active"] = this.active;
        return data;
    }
}

export interface INiveauOutputDto {
    niveauId: number;
    nom: string;
    ordre: number;
    pointMin: number;
    pointMax: number;
    active: boolean;

    [key: string]: any;
}

export class LangueMobileOutputDto implements ILangueMobileOutputDto {
    langueId!: number;
    nom!: string;
    codeLangue!: string;

    [key: string]: any;

    constructor(data?: ILangueMobileOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.langueId = _data["langueId"];
            this.nom = _data["nom"];
            this.codeLangue = _data["codeLangue"];
        }
    }

    static fromJS(data: any): LangueMobileOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LangueMobileOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["langueId"] = this.langueId;
        data["nom"] = this.nom;
        data["codeLangue"] = this.codeLangue;
        return data;
    }
}

export interface ILangueMobileOutputDto {
    langueId: number;
    nom: string;
    codeLangue: string;

    [key: string]: any;
}

export class LangueOutputDto implements ILangueOutputDto {
    langueId!: number;
    nom!: string;
    codeLangue!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: ILangueOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.langueId = _data["langueId"];
            this.nom = _data["nom"];
            this.codeLangue = _data["codeLangue"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): LangueOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new LangueOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["langueId"] = this.langueId;
        data["nom"] = this.nom;
        data["codeLangue"] = this.codeLangue;
        data["active"] = this.active;
        return data;
    }
}

export interface ILangueOutputDto {
    langueId: number;
    nom: string;
    codeLangue: string;
    active: boolean;

    [key: string]: any;
}

export class DictionnaireOutputDto implements IDictionnaireOutputDto {
    dictionnaireId!: number;
    dictionnaireType!: string;
    mot!: string;
    active!: boolean;
    image!: string;

    [key: string]: any;

    constructor(data?: IDictionnaireOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dictionnaireId = _data["dictionnaireId"];
            this.dictionnaireType = _data["dictionnaireType"];
            this.mot = _data["mot"];
            this.active = _data["active"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): DictionnaireOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionnaireOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dictionnaireId"] = this.dictionnaireId;
        data["dictionnaireType"] = this.dictionnaireType;
        data["mot"] = this.mot;
        data["active"] = this.active;
        data["image"] = this.image;
        return data;
    }
}

export interface IDictionnaireOutputDto {
    dictionnaireId: number;
    dictionnaireType: string;
    mot: string;
    active: boolean;
    image: string;

    [key: string]: any;
}

export class ChapitreGroupOutputDto implements IChapitreGroupOutputDto {
    chapitre!: ChapitreOutputDto;
    cours!: CoursOutputDto[];

    [key: string]: any;

    constructor(data?: IChapitreGroupOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.chapitre = _data["chapitre"] ? ChapitreOutputDto.fromJS(_data["chapitre"]) : <any>undefined;
            if (Array.isArray(_data["cours"])) {
                this.cours = [] as any;
                for (let item of _data["cours"])
                    this.cours!.push(CoursOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChapitreGroupOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChapitreGroupOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["chapitre"] = this.chapitre ? this.chapitre.toJSON() : <any>undefined;
        if (Array.isArray(this.cours)) {
            data["cours"] = [];
            for (let item of this.cours)
                data["cours"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChapitreGroupOutputDto {
    chapitre: ChapitreOutputDto;
    cours: CoursOutputDto[];

    [key: string]: any;
}

export class ChapitreOutputDto implements IChapitreOutputDto {
    chapitreId!: number;
    nomChapitre!: string;
    codeChapitre!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IChapitreOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.chapitreId = _data["chapitreId"];
            this.nomChapitre = _data["nomChapitre"];
            this.codeChapitre = _data["codeChapitre"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): ChapitreOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChapitreOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["chapitreId"] = this.chapitreId;
        data["nomChapitre"] = this.nomChapitre;
        data["codeChapitre"] = this.codeChapitre;
        data["active"] = this.active;
        return data;
    }
}

export interface IChapitreOutputDto {
    chapitreId: number;
    nomChapitre: string;
    codeChapitre: string;
    active: boolean;

    [key: string]: any;
}

export class CoursOutputDto implements ICoursOutputDto {
    id!: number;
    codeCours!: string;
    nomCours!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: ICoursOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.codeCours = _data["codeCours"];
            this.nomCours = _data["nomCours"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): CoursOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["codeCours"] = this.codeCours;
        data["nomCours"] = this.nomCours;
        data["active"] = this.active;
        return data;
    }
}

export interface ICoursOutputDto {
    id: number;
    codeCours: string;
    nomCours: string;
    active: boolean;

    [key: string]: any;
}

export class AudioDto implements IAudioDto {
    audio!: string;
    id!: number;
    dictionnaireId!: number;

    [key: string]: any;

    constructor(data?: IAudioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.audio = _data["audio"];
            this.id = _data["id"];
            this.dictionnaireId = _data["dictionnaireId"];
        }
    }

    static fromJS(data: any): AudioDto {
        data = typeof data === 'object' ? data : {};
        let result = new AudioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["audio"] = this.audio;
        data["id"] = this.id;
        data["dictionnaireId"] = this.dictionnaireId;
        return data;
    }
}

export interface IAudioDto {
    audio: string;
    id: number;
    dictionnaireId: number;

    [key: string]: any;
}

export class CoursDetailDto implements ICoursDetailDto {
    nomQuiz!: string;
    correctMotLangue!: string;
    correctAudio!: string;
    motFrancais!: string;
    audio!: string;
    enonce!: string;
    templateId!: number;
    contenuLangueId!: number;
    dictionnaireId!: number;
    codeTemplate!: string;
    audios!: AudioDto[];
    propositionFr!: ListMotsFrDto[];
    propositionLang!: ListMotsLangDto[];
    motLangues!: MotsDto[];
    pictures!: ImagesDto[];
    motLanguesForCours!: ListMotsLangForCoursExercice[];
    motsFrDtosForCours!: ListMotsFrDtoForCoursExercice[];

    [key: string]: any;

    constructor(data?: ICoursDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nomQuiz = _data["nomQuiz"];
            this.correctMotLangue = _data["correctMotLangue"];
            this.correctAudio = _data["correctAudio"];
            this.motFrancais = _data["motFrancais"];
            this.audio = _data["audio"];
            this.enonce = _data["enonce"];
            this.templateId = _data["templateId"];
            this.contenuLangueId = _data["contenuLangueId"];
            this.dictionnaireId = _data["dictionnaireId"];
            this.codeTemplate = _data["codeTemplate"];
            if (Array.isArray(_data["audios"])) {
                this.audios = [] as any;
                for (let item of _data["audios"])
                    this.audios!.push(AudioDto.fromJS(item));
            }
            if (Array.isArray(_data["propositionFr"])) {
                this.propositionFr = [] as any;
                for (let item of _data["propositionFr"])
                    this.propositionFr!.push(ListMotsFrDto.fromJS(item));
            }
            if (Array.isArray(_data["propositionLang"])) {
                this.propositionLang = [] as any;
                for (let item of _data["propositionLang"])
                    this.propositionLang!.push(ListMotsLangDto.fromJS(item));
            }
            if (Array.isArray(_data["motLangues"])) {
                this.motLangues = [] as any;
                for (let item of _data["motLangues"])
                    this.motLangues!.push(MotsDto.fromJS(item));
            }
            if (Array.isArray(_data["pictures"])) {
                this.pictures = [] as any;
                for (let item of _data["pictures"])
                    this.pictures!.push(ImagesDto.fromJS(item));
            }
            if (Array.isArray(_data["motLanguesForCours"])) {
                this.motLanguesForCours = [] as any;
                for (let item of _data["motLanguesForCours"])
                    this.motLanguesForCours!.push(ListMotsLangForCoursExercice.fromJS(item));
            }
            if (Array.isArray(_data["motsFrDtosForCours"])) {
                this.motsFrDtosForCours = [] as any;
                for (let item of _data["motsFrDtosForCours"])
                    this.motsFrDtosForCours!.push(ListMotsFrDtoForCoursExercice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CoursDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nomQuiz"] = this.nomQuiz;
        data["correctMotLangue"] = this.correctMotLangue;
        data["correctAudio"] = this.correctAudio;
        data["motFrancais"] = this.motFrancais;
        data["audio"] = this.audio;
        data["enonce"] = this.enonce;
        data["templateId"] = this.templateId;
        data["contenuLangueId"] = this.contenuLangueId;
        data["dictionnaireId"] = this.dictionnaireId;
        data["codeTemplate"] = this.codeTemplate;
        if (Array.isArray(this.audios)) {
            data["audios"] = [];
            for (let item of this.audios)
                data["audios"].push(item.toJSON());
        }
        if (Array.isArray(this.propositionFr)) {
            data["propositionFr"] = [];
            for (let item of this.propositionFr)
                data["propositionFr"].push(item.toJSON());
        }
        if (Array.isArray(this.propositionLang)) {
            data["propositionLang"] = [];
            for (let item of this.propositionLang)
                data["propositionLang"].push(item.toJSON());
        }
        if (Array.isArray(this.motLangues)) {
            data["motLangues"] = [];
            for (let item of this.motLangues)
                data["motLangues"].push(item.toJSON());
        }
        if (Array.isArray(this.pictures)) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        if (Array.isArray(this.motLanguesForCours)) {
            data["motLanguesForCours"] = [];
            for (let item of this.motLanguesForCours)
                data["motLanguesForCours"].push(item.toJSON());
        }
        if (Array.isArray(this.motsFrDtosForCours)) {
            data["motsFrDtosForCours"] = [];
            for (let item of this.motsFrDtosForCours)
                data["motsFrDtosForCours"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICoursDetailDto {
    nomQuiz: string;
    correctMotLangue: string;
    correctAudio: string;
    motFrancais: string;
    audio: string;
    enonce: string;
    templateId: number;
    contenuLangueId: number;
    dictionnaireId: number;
    codeTemplate: string;
    audios: AudioDto[];
    propositionFr: ListMotsFrDto[];
    propositionLang: ListMotsLangDto[];
    motLangues: MotsDto[];
    pictures: ImagesDto[];
    motLanguesForCours: ListMotsLangForCoursExercice[];
    motsFrDtosForCours: ListMotsFrDtoForCoursExercice[];

    [key: string]: any;
}

export class ImagesDto implements IImagesDto {
    picture!: string;
    id!: number;
    dictionnaireId!: number;

    [key: string]: any;

    constructor(data?: IImagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.picture = _data["picture"];
            this.id = _data["id"];
            this.dictionnaireId = _data["dictionnaireId"];
        }
    }

    static fromJS(data: any): ImagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["picture"] = this.picture;
        data["id"] = this.id;
        data["dictionnaireId"] = this.dictionnaireId;
        return data;
    }
}

export interface IImagesDto {
    picture: string;
    id: number;
    dictionnaireId: number;

    [key: string]: any;
}

export class ListMotsFrDto implements IListMotsFrDto {
    mot!: string;
    id!: number;

    [key: string]: any;

    constructor(data?: IListMotsFrDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mot = _data["mot"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListMotsFrDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListMotsFrDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mot"] = this.mot;
        data["id"] = this.id;
        return data;
    }
}

export interface IListMotsFrDto {
    mot: string;
    id: number;

    [key: string]: any;
}

export class ListMotsFrDtoForCoursExercice implements IListMotsFrDtoForCoursExercice {
    mot!: string;
    correct!: boolean;

    [key: string]: any;

    constructor(data?: IListMotsFrDtoForCoursExercice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mot = _data["mot"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): ListMotsFrDtoForCoursExercice {
        data = typeof data === 'object' ? data : {};
        let result = new ListMotsFrDtoForCoursExercice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mot"] = this.mot;
        data["correct"] = this.correct;
        return data;
    }
}

export interface IListMotsFrDtoForCoursExercice {
    mot: string;
    correct: boolean;

    [key: string]: any;
}

export class ListMotsLangDto implements IListMotsLangDto {
    mot!: string;
    id!: number;

    [key: string]: any;

    constructor(data?: IListMotsLangDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mot = _data["mot"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListMotsLangDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListMotsLangDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mot"] = this.mot;
        data["id"] = this.id;
        return data;
    }
}

export interface IListMotsLangDto {
    mot: string;
    id: number;

    [key: string]: any;
}

export class ListMotsLangForCoursExercice implements IListMotsLangForCoursExercice {
    mot!: string;
    correct!: boolean;

    [key: string]: any;

    constructor(data?: IListMotsLangForCoursExercice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mot = _data["mot"];
            this.correct = _data["correct"];
        }
    }

    static fromJS(data: any): ListMotsLangForCoursExercice {
        data = typeof data === 'object' ? data : {};
        let result = new ListMotsLangForCoursExercice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mot"] = this.mot;
        data["correct"] = this.correct;
        return data;
    }
}

export interface IListMotsLangForCoursExercice {
    mot: string;
    correct: boolean;

    [key: string]: any;
}

export class MotsDto implements IMotsDto {
    mot!: string;
    id!: number;

    [key: string]: any;

    constructor(data?: IMotsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mot = _data["mot"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MotsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MotsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mot"] = this.mot;
        data["id"] = this.id;
        return data;
    }
}

export interface IMotsDto {
    mot: string;
    id: number;

    [key: string]: any;
}

export class CoursDetailTemplateDto implements ICoursDetailTemplateDto {
    coursDetailTemplateId!: number;
    code!: string;
    libelle!: string;

    [key: string]: any;

    constructor(data?: ICoursDetailTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.coursDetailTemplateId = _data["coursDetailTemplateId"];
            this.code = _data["code"];
            this.libelle = _data["libelle"];
        }
    }

    static fromJS(data: any): CoursDetailTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursDetailTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["coursDetailTemplateId"] = this.coursDetailTemplateId;
        data["code"] = this.code;
        data["libelle"] = this.libelle;
        return data;
    }
}

export interface ICoursDetailTemplateDto {
    coursDetailTemplateId: number;
    code: string;
    libelle: string;

    [key: string]: any;
}

export class ConteOutputDto implements IConteOutputDto {
    nom!: string;
    contenuConte!: string;
    audioConte!: string;
<<<<<<< HEAD
=======
    image!: string;
>>>>>>> origin/jessica
    active!: boolean;

    [key: string]: any;

    constructor(data?: IConteOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nom = _data["nom"];
            this.contenuConte = _data["contenuConte"];
            this.audioConte = _data["audioConte"];
<<<<<<< HEAD
=======
            this.image = _data["image"];
>>>>>>> origin/jessica
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): ConteOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConteOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nom"] = this.nom;
        data["contenuConte"] = this.contenuConte;
        data["audioConte"] = this.audioConte;
<<<<<<< HEAD
=======
        data["image"] = this.image;
>>>>>>> origin/jessica
        data["active"] = this.active;
        return data;
    }
}

export interface IConteOutputDto {
    nom: string;
    contenuConte: string;
    audioConte: string;
<<<<<<< HEAD
=======
    image: string;
>>>>>>> origin/jessica
    active: boolean;

    [key: string]: any;
}

export class ContenuLangueOutputDto implements IContenuLangueOutputDto {
    id!: number;
    dictionnaireId!: number;
    mot!: string;
    audio!: string;
    active!: boolean;

    [key: string]: any;

    constructor(data?: IContenuLangueOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.dictionnaireId = _data["dictionnaireId"];
            this.mot = _data["mot"];
            this.audio = _data["audio"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): ContenuLangueOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContenuLangueOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["dictionnaireId"] = this.dictionnaireId;
        data["mot"] = this.mot;
        data["audio"] = this.audio;
        data["active"] = this.active;
        return data;
    }
}

export interface IContenuLangueOutputDto {
    id: number;
    dictionnaireId: number;
    mot: string;
    audio: string;
    active: boolean;

    [key: string]: any;
}

export class LangueGroupDto implements ILangueGroupDto {
    langue!: LangueOutputDto;
    contenus!: ContenuLangueOutputDto[];

    [key: string]: any;

    constructor(data?: ILangueGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.langue = _data["langue"] ? LangueOutputDto.fromJS(_data["langue"]) : <any>undefined;
            if (Array.isArray(_data["contenus"])) {
                this.contenus = [] as any;
                for (let item of _data["contenus"])
                    this.contenus!.push(ContenuLangueOutputDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LangueGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LangueGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["langue"] = this.langue ? this.langue.toJSON() : <any>undefined;
        if (Array.isArray(this.contenus)) {
            data["contenus"] = [];
            for (let item of this.contenus)
                data["contenus"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILangueGroupDto {
    langue: LangueOutputDto;
    contenus: ContenuLangueOutputDto[];

    [key: string]: any;
}

export class ChapitreCoursDto implements IChapitreCoursDto {
    nomChapitre!: string;
    codeChapitre!: string;
    estTermine!: boolean;
    enCours!: boolean;
    cours!: CoursDto[];

    [key: string]: any;

    constructor(data?: IChapitreCoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nomChapitre = _data["nomChapitre"];
            this.codeChapitre = _data["codeChapitre"];
            this.estTermine = _data["estTermine"];
            this.enCours = _data["enCours"];
            if (Array.isArray(_data["cours"])) {
                this.cours = [] as any;
                for (let item of _data["cours"])
                    this.cours!.push(CoursDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChapitreCoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChapitreCoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nomChapitre"] = this.nomChapitre;
        data["codeChapitre"] = this.codeChapitre;
        data["estTermine"] = this.estTermine;
        data["enCours"] = this.enCours;
        if (Array.isArray(this.cours)) {
            data["cours"] = [];
            for (let item of this.cours)
                data["cours"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChapitreCoursDto {
    nomChapitre: string;
    codeChapitre: string;
    estTermine: boolean;
    enCours: boolean;
    cours: CoursDto[];

    [key: string]: any;
}

export class CoursDto implements ICoursDto {
    coursId!: number;
    nomCours!: string;
    estTermine!: boolean;
    enCours!: boolean;

    [key: string]: any;

    constructor(data?: ICoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.coursId = _data["coursId"];
            this.nomCours = _data["nomCours"];
            this.estTermine = _data["estTermine"];
            this.enCours = _data["enCours"];
        }
    }

    static fromJS(data: any): CoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["coursId"] = this.coursId;
        data["nomCours"] = this.nomCours;
        data["estTermine"] = this.estTermine;
        data["enCours"] = this.enCours;
        return data;
    }
}

export interface ICoursDto {
    coursId: number;
    nomCours: string;
    estTermine: boolean;
    enCours: boolean;

    [key: string]: any;
}

export class Body implements IBody {
    input!: DefinirCoursInputOuputDto;
    type!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.input = _data["input"] ? DefinirCoursInputOuputDto.fromJS(_data["input"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IBody {
    input: DefinirCoursInputOuputDto;
    type: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}